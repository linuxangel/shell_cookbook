{"name":"Shell cookbook","tagline":"让你的shell 风生水起","body":"######第一章Shell  之讨厌的正则 \r\n###linux 天使团团长：隋成龙\r\n###编辑整理：邢耀东\r\n###代码测试：韩国梁\r\n###版本美化: 杨飞\r\n* 思想（KISS）相当重要.\r\n*\t我们遵循KISS原则  （keep it simple，stupid） \r\n*   这事其实不难，只要按照以下思路进行就行了。 \r\n\r\n>1.  把复杂的问题简单化，模块化 \r\n>2.  写出每一个模块的伪码。 \r\n>3.  组装你的模块 \r\n>4.  写出shell code \r\n>5.   测试（test） \r\n\r\n\r\n####知道什么时候用什么实现，远比你知道怎么写code更重要。（shell不是万能的，择优取之。\r\n####shell最精华，最美的地方在于有现成的命令可以使用，不用考虑过多的底层的问题。作为上\r\n####层工作的最好的工具，所谓上层系统管理，网络管理等等。） \r\n\r\n###战略决定生死，细节决定成败 \r\n##以下是我们以后将要更新的章节\r\n\r\n*\t讨厌的正则\r\n*\t可爱的变量\r\n*\t简单明了的输入输出\r\n*\t神奇的判断\r\n*\t不可不会的文件操作\r\n*\t瞬间飞升\r\n\r\n###第一节讨厌的正则\r\n\r\n*    之所以讨厌一个事物，是因为你驾驭不了它。\r\n\r\n>*\t乱七八糟的符号。\r\n>       举例：（grep  为行模式，默认以行显示）\r\n>\r\n>>  (1)\r\n>><pre><code>[root@localhost ~]# cat /etc/passwd | grep --color \"r..t\"\r\nroot:x:0:0:root:/root:/bin/bash\r\noperator:x:11:0:operator:/root:/sbin/nologin\r\nftp:x:14:50:FTP User:/var/ftp:/sbin/nologin\r\n[root@localhost ~]# \r\n</code></pre>\r\n>\r\n>><p>显示三行</p>\r\n\r\n>>  (2)\r\n>><pre><code>[root@localhost ~]# cat /etc/passwd | grep --color 'root'\r\nroot:x:0:0:root:/root:/bin/bash\r\noperator:x:11:0:operator:/root:/sbin/nologin\r\n[root@localhost ~]#\r\n</code></pre>\r\n>><p>显示两行</p>\r\n>>\t(3)\r\n>><pre><code>[root@localhost ~]# cat /etc/passwd | grep --color '^root'\r\nroot:x:0:0:root:/root:/bin/bash\r\n[root@localhost ~]#\r\n</code></pre>\r\n>><p>显示一行 </p> \r\n> \r\n>>*\t总结以上`:`什么是正则，两个单引号中间的部分就是正则。 \r\n> \r\n>\r\n>*    2.正则有什么用？</p> \r\n>\r\n>***\r\n>> <p>1.\t查找匹配</p>\r\n> \r\n>><p> 1)一个字符（如何在整篇文章中查找一个字符），正则提供了一些特殊符号，通过这\r\n些符号去替换一些东西.</p>\r\n>>\r\n><p>举例：在整篇文章中查找字母a</p> \r\n>\t\t\r\n>>使用vi编辑器打开/etc/passwd \r\n\r\n>>在末行模式下查找a \r\n>输入   ：/a/  \r\n>比如要查找abc，是一个或的关系,那么用 [ ] 。  \r\n>>输入  ：/[abc]/      \r\n>    ：/[a-c]/  \r\n>\t：/a|b|c/\r\n>\r\n>>中括号，把你想要定位的东西写入里面。\r\n> \r\n>>`.`\t任意一个字符。 \r\n> \r\n>>`[]`  选择中括号里面的任意一个。 \r\n> \r\n>>`[^]`  取非，取反 \r\n> \r\n>>`[:alnum:]`阿尔法字符加数字 \r\n> \r\n>>`[:alpha:]`任意一个字符`[[:alpha]]` \r\n> \r\n>>`[:digit:]`任意一个数字 `[[:digit:]]`（对它取反的话`[^[:digit:]]`）意为除了任意一个数字。 \r\n> \r\n>>`[:lower:]`小写。  \r\n> \r\n>>`[:upper:]`大写。\r\n>\r\n>>`[:space:]`空格。\r\n>\r\n>>`[:punct:]`标点。\r\n>\r\n>>*\t总结`：`以上是如何定位一个字符。\r\n>\r\n>><p>简单的实例</p>\r\n>><code><pre>[root@localhost ~]# cat testfile | grep --color '.'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# cat testfile | grep --color 'dog'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# cat testfile | grep --color '[d|D]og'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# cat testfile | grep --color '[^dD]og'\r\npig pig .og\r\n[root@localhost ~]# cat testfile | grep --color -E 'd|p' \r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]#\r\n</code></pre>\r\n>><p>备注  –E 代表的是一个扩展的表达方式。其中dp之间的  |  代表的是或的关系，任意取一。</p>\r\n\r\n> \r\n>>转义字符  `\\` \r\n>\r\n>><p>举例：</p>\r\n>\r\n>>当 `.`  在这不转义的时候就代表是正则中的 .  代表的是匹配任意一个字符。 \r\n> \r\n>><pre><code>[root@localhost ~]# cat testfile | grep --color -E 'd.g'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# \r\n></code></pre>\r\n>><p>当`\\.`转义之后代表着文本中存在的具体的 `.`</p> \r\n> ***\r\n>*\t2.字符的边界，查找匹配多个字符用到字符边界。\r\n>>\r\n>>`^`开头（一行开头）\t\r\n>\r\n>>`$`  结尾（一行结尾） \r\n> \r\n>>`\\<`左边界\r\n>\r\n>>`\\>`右边界     \r\n>><pre><code>[root@localhost ~]# cat -A /etc/passwd\r\nroot:x:0:0:root:/root:/bin/bash$\r\nbin:x:1:1:bin:/bin:/sbin/nologin$\r\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin$\r\nadm:x:3:4:adm:/var/adm:/sbin/nologin$\r\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin$\r\nsync:x:5:0:sync:/sbin:/bin/sync$\r\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown$\r\nhalt:x:7:0:halt:/sbin:/sbin/halt$\r\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin$\r\nuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin$\r\noperator:x:11:0:operator:/root:/sbin/nologin$\r\ngames:x:12:100:games:/usr/games:/sbin/nologin$\r\ngopher:x:13:30:gopher:/var/gopher:/sbin/nologin$\r\nftp:x:14:50:FTP User:/var/ftp:/sbin/nologin$\r\n.......\r\n</code></pre>\r\n>><p>以上结尾为`$`代表着这一行的字符边界。</p>\r\n>><p>linux与windows之间格式在linux下面的转换方法</p>\r\n>><p>命令`dos2unix` win格式转换linux </p>\r\n>><p>命令`unix2dos`  linux格式转换成win</p>\r\n>***\r\n>*\t3.重复\r\n>><p> *  重复0次或多次。注意ls *  中的 * 不是正则，是shell中的通配符。正则中的*代表前面出现了0次或者多次。  * 〉=0 </p>\r\n>><p>举例：匹配所有字符，字符每个出现次数大于等于0次 </p>\r\n>><pre><code>\r\n[root@localhost ~]# cat testfile |  grep --color '.*'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>>***\r\n>><p>a的次数大于等于0次，字符中没有a，它就相当于没有，所以匹配所有。</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color 'a*'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>>***\r\n>><p>字符中有d，第一行出现一次。第二行没有出现等于0次，那么匹配。第三行一次，第四行没\r\n有那就等于0次，那么匹配。</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color 'd*'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>>***\r\n>><p>匹配d，所有出现d的行都匹配出来。 </p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color 'd'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>***\r\n>><p>+匹配一个或者多个。+〉=1 </p> \r\n>><p>举例：匹配d，d+  表示每一行匹配d的次数大于等于1.</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E 'd+'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]#</code></pre>\r\n>***\r\n>><p>？匹配0个或者一个。〈=1 </p>\r\n>><p>举例：匹配d，  d？  表示每一行匹配d的次数小于等于一次。</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E 'd?'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog</code></pre>\r\n>***\r\n>><p>精确匹配次数。 </p>\r\n>><p>{}  中填入数字代表匹配次数。大于等于次数的行被匹配出。</p> \r\n>><p>举例：a精确匹配5次。a出现的次数大于等于5次的行被匹配。</p>\r\n>\r\n>><pre><code>[root@localhost ~]# cat testfile \r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\naa\r\naaa\r\naaaa\r\naaaaa\r\naaaaa\r\naaaaaaa\r\naaaaaaaa\r\n[root@localhost ~]# cat testfile |  grep --color 'a\\{5\\}'\r\naaaaa\r\naaaaa\r\naaaaaaa\r\naaaaaaaa\r\n[root@localhost ~]# \r\n>></code></pre>\r\n>***\r\n>><p>精确到范围。</p> \r\n>><p>{n，m} </p>  \r\n>><p>举例：匹配3至5，包括3和5.</p>\r\n>><code><pre>[root@localhost ~]# cat testfile |  grep --color 'a\\{3,5\\}'\r\naaa\r\naaaa\r\naaaaa\r\naaaaa\r\naaaaaaa\r\naaaaaaaa\r\n[root@localhost ~]# </code></pre>\r\n>***\r\n>*\t4.组 \r\n>*\t组的重复\r\n>><p>举例：pig一组，dog一组。其中的  | 有或的意思，如果有组pig或者dog，就匹配这一行。 </p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog)+'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>***\r\n>><p>pig一组，dog一组。Pig或者dog出现的次数大于等于1次，就匹配这一行。 </p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog)+'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dogdog !dog ddog!\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>***\r\n>><p>Pig一组，dog一组。Pig或者dog出现满足某一行精确到出现两次就匹配。</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog){2}'\r\ndog d.g dogdog !dog ddog!\r\n[root@localhost ~]#</code></pre>\r\n>***\r\n###第二章Shell之可爱的变量###\r\n\r\n\r\n<p>知止，知道正则在什么时候停止。</p>\r\n<p><I>知止而后能定，定而后能静，静而后能安，安而后能虑，虑而后能得。\r\n\t\t\t\t\t\t\t\t\t<br>&copy;语出</I>《大学》</p>\r\n<p>正则本身是个贪婪模式，当你发现 `.*` 会匹配所有的东西。所以应该知道正则在哪停止。</p>\r\n<p>我们的课程是一门有思想的shell课程.</p>\r\n<p>######知识列表######</p>\r\n<p>1.\tbash的通配符</p>\r\n<p>2.\t设定变量</p>\r\n<p>3.\t变量的工作范围</p>\r\n<p>4.\t变量的一些有意思的用法</p>\r\n<p>5.\t有用的自带变量</p>\r\n<p>6.\t有趣的操作符号</p>\r\n<p>7.\t数学运算与数组</p>\r\n\r\n* 一.\tbash通配符\r\n\r\n<p>shell常见通配符</p>\r\n<table>\r\n<tr>\r\n<th><I>字符</I></th>\r\n<th><I>含义</I></th>\r\n<th><I>实例</I></th>\r\n</tr>\r\n<tr>\r\n<th><I>*</I></th>\r\n<th><I>匹配0或多个字符</I></th>\r\n<th><I>a*b a与b之间可以有任意长度的任意字符，也可以一个也没有，如：aabcb，axyzb，a012b，ab.</I></th>\r\n</tr>\r\n<tr>\r\n<th><I>？</I></th>\r\n<th><I>匹配任意字符</I></th>\r\n<th><I>a？b a与b之间必须也只能由一个字符，可以是任意字符，如aab，abb，acb，a0b.</I></th>\r\n</tr>\r\n<tr>\r\n<th><I>[list]</I></th>\r\n<th><I>匹配list中的任意单一字符</I></th>\r\n\r\n<th><I>a[xyz]b a与b之间必须也只能有一个字符，但只能是x或y或z，如axb，ayb，azb. </I></th>\r\n</tr>\r\n<tr>\r\n<th><I>[！list]</I></th>\r\n<th><I>匹配除list中的任意单一字符</I></th>\r\n<th><I>a[！0-9]b a与b之间必须也只能有一个字符，但不能是除阿拉伯数字.</I></th>\r\n</th>\r\n<tr>\r\n<th><I>[c1-c2]</I></th>\r\n<th><I>匹配c1-c2中的任意单一字符如：[0-9]</I></th>\r\n<th><I>a[0-9]b 0-9之间必须也只能有一个字符，如a0b，a1b，a2b…a9b.</I></th>\r\n</tr>\r\n<tr>\r\n<th><I>{string1,string2,…}</I></th>\r\n<th><I>匹配string1或者string2（或者更多）其一字符串</I></th>\r\n<th><I>a{abc，xyz，123}b a与b之间只能是abc或xyz或123 这三个字符串之一.</I></th>\r\n</tr>\r\n</table>\r\n\r\n<p>注：此处的 * 和正则中 * 的区别，正则中 * 始终出现在命令的参数部分。</p>\r\n<p>比如 ls * 中的* 代表的是通配符，而`grep ‘.*’/etc/passwd` 代表正则。</p>\r\n思考：`mkdir –pv /tmp/{a，b}/{1，2，3}`一共创建了多少个文件？\r\n[：digit：] 在这里任然适用\r\n查看一个文件名为数字文件ls –lh `[[：digit：]]`\r\n\r\n* 二． 设定变量。\r\n\r\n\r\n\t1〉变量名=值\r\n格式的要求“开头必须是字母或者下划线”，“=两边不能有空格”\r\n\r\n\t2〉取消变量\r\n\r\n\tunset 变量名\r\n\r\n举例：\r\n<pre><code>[root@localhost ~]# b=123 \r\n[root@localhost ~]# a=hello\r\n[root@localhost ~]# echo $a\r\nhello\r\n[root@localhost ~]# echo $b\r\n123\r\n[root@localhost ~]# unset a\r\n[root@localhost ~]# echo $a\r\n\r\n[root@localhost ~]#\r\n</code></pre>\r\n<p>在其他编程语言中需要区分变量类型，在shell中是不区分的，拿以上变量来说都是一个变量。</p>\r\n\r\n*\t三.\t变量的工作范围\r\n<p>设定一个变量在什么样一个范围内会生效，在什么时候继承下去。</p>\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# a=123\r\n[root@localhost ~]# bash\r\n[root@localhost ~]# echo $a\r\n\r\n[root@localhost ~]# \r\n</code></pre> \r\n\r\n<p>bash命令是在当前的进程产生一个子进程。</p>\r\n<p>父bash `a=123`</p>\r\n<p>子进程bash 在子进程中父进程的变量不生效。所以以上例子中没</p>\r\n<p>通过pstree命令可以看出整个过程。最顶端的那个进程为init，init为所有进程的父进程</p>\r\n\r\n<pre><code>\r\n[root@localhost ~]# pstree\r\ninit─┬─acpid\r\n     ├─atd\r\n     ├─auditd─┬─audispd───{audispd}\r\n     │        └─{auditd}\r\n     ├─automount───4*[{automount}]\r\n     ├─avahi-daemon───avahi-daemon\r\n     ├─crond\r\n     ├─cupsd\r\n     ├─dbus-daemon───{dbus-daemon}\r\n     ├─2*[dhclient]\r\n     ├─events/0\r\n     ├─gam_server\r\n     ├─gpm\r\n     ├─hald───hald-runner─┬─hald-addon-acpi\r\n     │                    ├─hald-addon-keyb\r\n     │                    └─hald-addon-stor\r\n     ├─hcid\r\n     ├─hidd\r\n     ├─httpd───10*[httpd]\r\n     ├─khelper\r\n     ├─klogd\r\n     ├─krfcommd\r\n     ├─ksoftirqd/0\r\n     ├─kthread─┬─aio/0\r\n     │         ├─ata/0\r\n .....\r\n</code></pre>\r\n\r\n<p>在当前shell中打开一个shell，使用bash命令。退出子shell，使用exit.</p>\r\n<p>变量只在当前生效：</p>\r\n<pre><code>\r\n[root@localhost ~]# a=123\r\n[root@localhost ~]# bash\r\n[root@localhost ~]# echo $a\r\n\r\n[root@localhost ~]# \r\n</code></pre> \r\n<p>变量继承，在所有子进程中生效。export 命令向下影响所有的子进程。</p>\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# a=123\r\n[root@localhost ~]# export a\r\n[root@localhost ~]# bash\r\n[root@localhost ~]# echo $a\r\n123\r\n[root@localhost ~]#\r\n</code></pre>\r\n*\t系统变量和环境变量\r\n<p>set 返回结果包含环境变量和局部变量。</p>\r\n<p>env 返回结果包含环境变量。</p>\r\n<pre><code>\r\n[root@localhost ~]# set\r\nBASH=/bin/bash\r\nBASH_ARGC=()\r\nBASH_ARGV=()\r\nBASH_LINENO=()\r\nBASH_SOURCE=()\r\nBASH_VERSINFO=([0]=\"3\" [1]=\"2\" [2]=\"25\" [3]=\"1\" [4]=\"release\" [5]=\"i686-redhat-linux-gnu\")\r\nBASH_VERSION='3.2.25(1)-release'\r\nCOLORS=/etc/DIR_COLORS\r\nCOLUMNS=168\r\nCVS_RSH=ssh\r\nDIRSTACK=()\r\nEUID=0\r\nGROUPS=()\r\nG_BROKEN_FILENAMES=1\r\nHISTFILE=/root/.bash_history\r\nHISTFILESIZE=1000\r\nHISTSIZE=1000\r\nHOME=/root\r\nHOSTNAME=localhost.localdomain\r\nHOSTTYPE=i686\r\nIFS=$' \\t\\n'\r\nINPUTRC=/etc/inputrc\r\nLANG=zh_CN.UTF-8\r\nLESSOPEN='|/usr/bin/lesspipe.sh %s'\r\n.....\r\n</code></pre>\r\n\r\n<pre><code>\r\n[root@localhost ~]# env\r\nHOSTNAME=localhost.localdomain\r\nSHELL=/bin/bash\r\nTERM=linux\r\nHISTSIZE=1000\r\nSSH_CLIENT=172.16.10.101 55656 22\r\nSSH_TTY=/dev/pts/0\r\nUSER=root\r\nLS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:\r\nPATH=/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin\r\nMAIL=/var/spool/mail/root\r\nPWD=/root\r\nINPUTRC=/etc/inputrc\r\na=123\r\nLANG=zh_CN.UTF-8\r\nHOME=/root\r\nSHLVL=4\r\nLOGNAME=root\r\nCVS_RSH=ssh\r\nSSH_CONNECTION=172.16.10.101 55656 172.16.10.104 22\r\nLESSOPEN=|/usr/bin/lesspipe.sh %s\r\nG_BROKEN_FILENAMES=1\r\n_=/bin/env\r\n[root@localhost ~]#\r\n</code></pre>\r\n<p>所谓系统变量：自己定义的一个变量就是系统变量。</p>\r\n<p>环境变量:通过env返回的结果为环境变量。</p>\r\n<p>以下四个变量的执行顺序是怎么排列：</p>\r\n<pre><code>\r\n/etc/ profile\r\n~/.bash_profile\r\n~/.bashrc\r\n/etc/bashrc\r\n</code></pre>\r\n<p>分别定义同一个变量不同的返回值。</p>\r\n<pre><code>/etc/ profile 中定义 a=123\r\n~/.bash_profile 中定义 a=234\r\n~/.bashrc 中定义 a=345\r\n/etc/bashrc a=456\r\n</code></pre>\r\n<p>那么其执行的先后顺序如下:</p>\r\n<pre><code>\r\n/etc/profile\r\n/root/.bash_profile\r\n/root/.bashrc\r\n/etc/bashrc\r\n</code></pre>\r\n\r\n<p>登陆shell和非登陆shell</p>\r\n<p>登陆shell是指当用户登陆系统时所取得的那个shell，通过查找以上四个不同的启动文件来处理其中的命令，bash处理顺序如下：</p>\r\n\t/etc/profile-----/$home/.bash_profile------/$home/.bashrc-------/etc/bashrc\r\n<p>非登陆shell</p>\r\n<p>`/etc/bashrc` 尽管不是通过bash直接调用，但许多`~/.bashrc`文件调用`/etc/bashrc`。这种设置使得超级用户可以为系统内的非登陆shell建立默认属性。</p>\r\n<p>`.bashrc`非登陆shell执行`~/.bashrc`文件中的命令，而登陆shell的启动文件（如`.bash_profile`）通常会运行这个文件。这样，登陆shell和非登陆shell都可以运行`.bashrc`中的命令了。</p>\r\n\r\n<p>典型的例子 su 和su –</p>\r\n<p>su – 登陆shell</p>\r\n<p>su 非登陆shell</p>\r\n<p>总结一下shell内置的环境变量有哪些？</p>\r\n***\r\n*\t四． 变量的有意思的用法。\r\n\r\n<pre><code>\r\n[root@localhost ~]# a=\r\n[root@localhost ~]# echo ${a:-hello}\r\nhello\r\n[root@localhost ~]# echo $a\r\n\r\n[root@localhost ~]#\r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# a=123\r\n[root@localhost ~]# echo ${a:-hello}\r\n123\r\n[root@localhost ~]# echo $a\r\n123\r\n[root@localhost ~]# \r\n</code></pre>\r\n<p>对比，当a没有值得时候，临时使用hello。当a有值的时候输出a的值。</p>\r\n<p>总结：`${var:-word} `如果var没有值，则临时设定值为`word`</p>\r\n***\r\n<pre><code>\r\n[root@localhost ~]# a=\r\n[root@localhost ~]# echo ${a:=hello}\r\nhello\r\n[root@localhost ~]# echo $a\r\nhello\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# a=123\r\n[root@localhost ~]# echo ${a:=hello}\r\n123\r\n[root@localhost ~]# echo $a\r\n123\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<p>对比以上，当a没有值的时候，会设定为hello。当a有值时输出a的值。</p>\r\n<p>总结 ：${var:=word}如果var没有值，设定为word。当var有值输出a的值。</p>\r\n***\r\n<pre><code>\r\n[root@localhost ~]# a=\r\n[root@localhost ~]# echo ${a:+hello}\r\n\r\n[root@localhost ~]# echo $a\r\n\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# a=123\r\n[root@localhost ~]# echo ${a:+hello}\r\nhello\r\n[root@localhost ~]# echo $a\r\n123\r\n[root@localhost ~]# \r\n</code></pre>\r\n<p>对比以上，当a有值时，会临时使用hello，但是值本身不改变。</p>\r\n<p>总结：${var:+word} 如果var有值，临时设定为word，但是var本身的值不改变。</p>\r\n***\r\n<pre><code>\r\n[root@localhost ~]# a=\r\n[root@localhost ~]# echo ${a:?hello}\r\nbash: a: hello\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# a=123\r\n[root@localhost ~]# echo ${a:?hello}\r\n123\r\n[root@localhost ~]# echo $a\r\n123\r\n[root@localhost ~]#\r\n\r\n</code></pre>\r\n<p>对比以上,如果a没有值，报错，如果a有值打印出a的值；</p>\r\n<p>总结：${var:?word} 如果var没有值，报错，如果var有值打印出var的值。</p>\r\n***\r\n<pre><code>\r\n[root@localhost ~]# a=hello\r\n[root@localhost ~]# echo ${a:0}\r\nhello\r\n[root@localhost ~]# echo ${a:1}\r\nello\r\n[root@localhost ~]# echo ${a:2}\r\nllo\r\n[root@localhost ~]# echo ${a:3}\r\nlo\r\n[root@localhost ~]# echo ${a:4}\r\no\r\n[root@localhost ~]# \r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# a=hello\r\n[root@localhost ~]# echo ${a:1:3}\r\nell\r\n[root@localhost ~]#\r\n\r\n</code></pre>\r\n<p>对比以上</p>\r\n<p>总结：${var:offset}从变量offset位置开始，输出到结束</p>\r\n<p>$(var:offset：length)从变量offset开始，输出length</p>\r\n***\r\n<pre><code>\r\n[root@localhost ~]# a=/usr/bin/bash\r\n[root@localhost ~]# echo ${a%/*}\r\n/usr/bin\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# a=/usr/bin/bash\r\n[root@localhost ~]# echo ${a%%/*}  \r\n\r\n[root@localhost ~]#\r\n\r\n</code></pre>\r\n<p>从a的值的结尾开始往前数，进行最小匹配，删除匹配部分。返回的是`/usr/bin`</p>\r\n<p>从a的值的结尾开始往前数，进行最大的匹配，并删除匹配的部分，那么返回值为空</p>\r\n<p>总结：${var%模式}从尾部开始，进行最小匹配,,然后删除匹配部分。</p>\r\n<p>${var%%模式}从尾部开始，进行最大匹配，然后删除匹配部分。</p>\r\n***\r\n<pre><code>\r\n[root@localhost ~]# a=/usr/bin/bash\r\n[root@localhost ~]# echo ${a#/*}   \r\nusr/bin/bash\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# a=/usr/bin/bash\r\n[root@localhost ~]# echo ${a##/*}  \r\n\r\n[root@localhost ~]# \r\n\r\n\r\n</code></pre>\r\n<p>以`/`分割，从左开始第一个/之前的部分（包括/）匹配，那么删除之前的部分。</p>\r\n<p>以`/`为分割，从左开始第一个直到结尾最后一个/的内容最大匹配，那么删除之前的部分。</p>\r\n<p>总结：`${var#模式}`从头部开始，进行最小匹配，然后删除匹配部分。</p>\r\n<p>`${var##模式}`从头部开始，进行最大匹配，然后删除匹配部分。</p>\r\n***\r\n<pre><code>[root@localhost ~]# a=nalmelaminceaneak\r\n[root@localhost ~]# echo ${#a}\r\n17\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# a=nsnkdknekalsmle1111\r\n[root@localhost ~]# echo ${#a}           \r\n19\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<p>变量之前的#是可以用来计算变量值中的字符串的。</p>\r\n<p>总结：${#var} 用来计算变量字符串。</p>\r\n<p>以上部分作为在shell中字符串的截取。其中 * 通配符，还可以用 ？号</p>\r\n***\r\n<pre><code>\r\n[root@localhost ~]# echo ${!P*}\r\nPATH PIPESTATUS PPID PS1 PS2 PS4 PWD\r\n[root@localhost ~]# \r\n\r\n</code></pre>\r\n<p>打印出系统中以P开头的变量。</p>\r\n<p>总结： `${!var@}`</p>\r\n<p>`${!var*}`</p>\r\n<p>打印系统中所有以var开头的变量。两者是一样的，唯一不同，@整个当字符串处理，*每个当字符串处理。（详细讲解，在以后循环章节再补充）</p>\r\n***\r\n*\t五． 有用的自带变量\r\n<p>$0,$1,$2…$9 $0代表脚本本身，$1参数的位置。注意当你的参数大于10时，变量的写法${10}\r\n,在10上加上 { } 。</p>\r\n<p>$#用来计算参数的个数。</p>\r\n<p>$* 与$@ 显示该脚本所有参数。</p>\r\n<p>举例：如下</p>\r\n\r\n<pre><code>\r\n[root@localhost ~]# vi test.sh\r\n#!/bin/bash\r\necho \\$1=$1\r\necho \\$2=$2\r\necho \\$3=$3\r\necho \\$4=$4\r\necho \\$5=$5\r\necho \\$6=$6\r\necho \\$7=$7\r\necho \\$8=$8\r\necho \\$9=$9\r\necho \\$10=${10}\r\n\r\necho \\$#=$#\r\necho \\$*=$*\r\necho \\$@=$@\r\n[root@localhost ~]# sh test.sh a b c d e f j k l m n \r\n$1=a\r\n$2=b\r\n$3=c\r\n$4=d\r\n$5=e\r\n$6=f\r\n$7=j\r\n$8=k\r\n$9=l\r\n$10=m\r\n$#=11\r\n$*=a b c d e f j k l m n\r\n$@=a b c d e f j k l m n\r\n[root@localhost ~]# \r\n</code></pre>\r\n***\r\n<p>$$ 指当前shell的PID</p>\r\n举例：\r\n<pre><code>[root@localhost ~]# echo $$\r\n25015\r\n[root@localhost ~]# \r\n</code></pre>\r\n\r\n***\r\n<p>$_ 上一条命令的最后一个参数。</p>\r\n举例：\r\n\r\n<pre><code>[root@localhost ~]# ps aux >/dev/null \r\n[root@localhost ~]# echo $_\r\naux\r\n[root@localhost ~]# \r\n</code></pre>\r\n<pre><code>\r\n[root@localhost ~]# ps -eo pid,ppid,comm >/dev/null \r\n[root@localhost ~]# echo $_\r\npid,ppid,comm\r\n[root@localhost ~]# grep -b -n root /etc/passwd\r\n1:0:root:x:0:0:root:/root:/bin/bash\r\n12:416:operator:x:11:0:operator:/root:/sbin/nologin\r\n[root@localhost ~]# \r\n</code></pre>\r\n<p>写这样一个脚本，只能在一个会话执行,能办到么？</p>\r\n***\r\n<p>$- 用来查看shell是否交互（himBH），其中有i就是交互式。</p>\r\n举例：\r\n<pre><code>[root@localhost ~]# echo $-\r\nhimBH\r\n[root@localhost ~]# \r\n</code></pre>\r\n***\r\n\r\n<p>$! 显示最后一个进入后台的作业的pid</p>\r\n<pre><code>\r\n[root@localhost ~]# sleep 10 &\r\n[1] 25652\r\n[root@localhost ~]# echo $!\r\n25652\r\n[root@localhost ~]#\r\n</code></pre>\r\n***\r\n<p>$? 上一条命令的返回值，0成功，非0部成功。</p>\r\n<pre><code>\r\n[root@localhost ~]# test\r\n[root@localhost ~]# echo $?\r\n1\r\n[root@localhost ~]# cd /\r\n[root@localhost /]# echo $?\r\n0\r\n[root@localhost /]# \r\n</code></pre>\r\n***\r\n*\t六． 有趣的操作符号\r\n<p>&& 前面的命令执行成功，则执行后面的命令执行</p>\r\n<p>|| 前面的命令执行不成功，则执行后面的命令执行</p>\r\n<p>`;` 命令的分割符号。</p>\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# echo hello | grep a && echo \"匹配\"\r\n[root@localhost ~]# echo hello | grep a || echo \"不匹配\"   \r\n不匹配\r\n[root@localhost ~]# echo hello | grep a && echo \"匹配\" || echo \"不匹配\"\r\n不匹配\r\n[root@localhost ~]# echo hello | grep hello && echo \"匹配\" || echo \"不匹配\" \r\nhello\r\n匹配\r\n[root@localhost ~]# echo hello | grep hello ; echo \"匹配\" || echo \"不匹配\"  \r\nhello\r\n匹配\r\n[root@localhost ~]# echo hello | grep hello ; echo \"匹配\" ; echo \"不匹配\"  \r\nhello\r\n匹配\r\n不匹配\r\n[root@localhost ~]# echo hello | grep a ; echo \"匹配\" ; echo \"不匹配\"      \r\n匹配\r\n不匹配\r\n[root@localhost ~]# \r\n</code></pre>\r\n\r\n<p>&& || 这两个符号太长的时候，关键看它之前执行之后返回的结果。</p>\r\n<p>； 前面命令不管成不成功都执行。</p>\r\n<p>& 后台操作符号。其实它可以实现并发的效果。</p>\r\n<p>例如：两个脚本</p>\r\n<pre><code>[root@localhost ~]# vi ping.sh\r\n#!/bin/bash\r\nping 172.16.10.1 -c 5 &\r\nping 172.16.10.101 -c 5 &\r\nping 172.16.10.104 -c 5 &\r\n***\r\n[root@localhost ~]# vi ping.sh1 \r\n#!/bin/bash\r\nping 172.16.10.1 -c 5\r\nping 172.16.10.101 -c 5\r\nping 172.16.10.104 -c 5\r\n</code></pre>\r\n<p>执行两个脚本后所用的时间对比</p>\r\n<pre><code>\r\n[root@localhost ~]# time `sh ping.sh` \r\nreal    0m4.987s\r\nuser    0m0.000s\r\nsys     0m0.017s\r\n[root@localhost ~]# time `sh ping.sh1`\r\nreal    0m15.018s\r\nuser    0m0.002s\r\nsys     0m0.039s\r\n[root@localhost ~]#\r\n</code></pre>\r\n\r\n<p>讨论并发的问题</p>\r\n<p>（） 合并输出，（）里面的命令在子shell中执行。</p>\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# cat /tmp/a\r\na\r\n[root@localhost ~]# cat /tmp/b\r\nb\r\n[root@localhost ~]# cat /tmp/a ; cat /tmp/b > /tmp/ab \r\na\r\n[root@localhost ~]# cat /tmp/ab \r\nb\r\n[root@localhost ~]# (cat /tmp/a ; cat /tmp/b) > /tmp/ab \r\n[root@localhost ~]# cat /tmp/ab \r\na\r\nb\r\n[root@localhost ~]#\r\n</code></pre>\r\n<p>（exit；）退出子shell</p>\r\n<p>{exit；}退出当前shell</p>\r\n***\r\n<p>$SHLVL 这个变量 可以查看你当前shell跑到了第几层。</p>\r\n\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# bash\r\n[root@localhost ~]# bash\r\n[root@localhost ~]# bash\r\n[root@localhost ~]# bash\r\n[root@localhost ~]# echo $SHLVL\r\n5\r\n[root@localhost ~]#\r\n</code></pre>\r\n<p>好处是在写shell脚本时，观察自己的变量在第几层执行。</p>\r\n<p>总结shell的内置变量，总结常用。</p>\r\n***\r\n<p>| 管道 把前面执行的结果，交给后面的命令处理。</p>\r\n<p>‘ ’强引用</p>\r\n<p>“ ”弱引用</p>\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# echo '$a'\r\n$a\r\n[root@localhost ~]# echo \"$a\"\r\ntest\r\n[root@localhost ~]#\r\n</code></pre>\r\n***\r\n<p>\\ 转义字符。所谓的转义就是把字符本身的含义转化成另外一个含义。根据不同的环境进行转移。</p>\r\n<p>`` 反引号，键盘1左边的那个反引号。 实际中shell在执行的过程中，先执行的 `` 里面的动作，再执行整个语句。在shell中不见意常用。</p>\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# echo `whoami`\r\nroot\r\n[root@localhost ~]# \r\n</code></pre>\r\n<p>$( ) 和 ` ` 执行效果一样，在shell脚本中建议使用$()</p>\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# echo $(whoami) \r\nroot\r\n[root@localhost ~]#\r\n</code></pre>\r\n***\r\n<p>eval 把后面的字符串当命令来使用。</p>\r\n举例：\r\n<pre><code>\r\n[root@localhost ~]# eval $(echo whoami) \r\nroot\r\n[root@localhost ~]# \r\n</code></pre>\r\n***\r\n<p>其他变量 type去查看</p>\r\n<pre><code>\r\n[root@localhost ~]# type /bin/echo \r\n/bin/echo is /bin/echo\r\n[root@localhost ~]# type test\r\ntest is a shell builtin\r\n[root@localhost ~]# \r\n</code></pre>\r\n***\r\n\r\n*\t七． 数学运算与数组。\r\n<p>复杂的数学运算使用bc，下面是简单的数学运算。</p>\r\n<pre><code>\r\n[root@localhost ~]# a=1\r\n[root@localhost ~]# b=2\r\n[root@localhost ~]# echo $a+$b\r\n1+2\r\n[root@localhost ~]# echo $[a+b]\r\n3\r\n[root@localhost ~]# echo $((a+b))\r\n3\r\n[root@localhost ~]# c=$a+$b\r\n[root@localhost ~]# echo $((c))\r\n3\r\n[root@localhost ~]# \r\n</code></pre>\r\n\r\n***\r\n<p>数组：</p>\r\n<p>定义数组：</p>\r\n<p>`Var=（word0 word1 word2 word3）`</p>\r\n<p>`echo ${var[0]}` 查看结果。</p>\r\n<pre><code>\r\n[root@localhost ~]# boss=(kk yy zz)\r\n[root@localhost ~]# echo ${boss[0]}\r\nkk\r\n[root@localhost ~]# echo ${boss[2]}\r\nzz\r\n[root@localhost ~]# echo ${boss[1]}\r\nyy\r\n[root@localhost ~]# echo ${boss[*]}\r\nkk yy zz\r\n[root@localhost ~]# echo ${#boss[*]}\r\n3\r\n[root@localhost ~]# echo ${#boss[0]}\r\n2\r\n[root@localhost ~]# unset boss\r\n[root@localhost ~]# echo ${#boss[*]}\r\n0\r\n[root@localhost ~]# boss=(kk yy zz) \r\n[root@localhost ~]# echo ${boss[*]} \r\nkk yy zz\r\n[root@localhost ~]# \r\n</code></pre>\r\n***\r\n<p>改变数组中的元素。</p>\r\n<pre><code>[root@localhost ~]# boss=(aa bb cc)\r\n[root@localhost ~]# echo ${boss[*]}\r\naa bb cc\r\n[root@localhost ~]# boss[1]=hello\r\n[root@localhost ~]# echo ${boss[*]}\r\naa hello cc\r\n[root@localhost ~]# \r\n</code></pre>\r\n<p>举例: 数组相当于古代的翻牌子</p>\r\n<p>妃子=（华妃 甄环）</p>\r\n***\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}