{"name":"Shell cookbook","tagline":"让你的shell 风生水起","body":"######第一章Shell  之讨厌的正则 \r\n###linux 天使团团长：隋成龙\r\n###编辑整理：邢耀东\r\n* 思想（KISS）相当重要.\r\n*\t我们遵循KISS原则  （keep it simple，stupid） \r\n*   这事其实不难，只要按照以下思路进行就行了。 \r\n\r\n>1.  把复杂的问题简单化，模块化 \r\n>2.  写出每一个模块的伪码。 \r\n>3.  组装你的模块 \r\n>4.  写出shell code \r\n>5.   测试（test） \r\n\r\n\r\n####知道什么时候用什么实现，远比你知道怎么写code更重要。（shell不是万能的，择优取之。\r\n####shell最精华，最美的地方在于有现成的命令可以使用，不用考虑过多的底层的问题。作为上\r\n####层工作的最好的工具，所谓上层系统管理，网络管理等等。） \r\n\r\n###战略决定生死，细节决定成败 \r\n##以下是我们以后将要更新的章节\r\n\r\n*\t讨厌的正则\r\n*\t可爱的变量\r\n*\t简单明了的输入输出\r\n*\t神奇的判断\r\n*\t不可不会的文件操作\r\n*\t瞬间飞升\r\n\r\n###第一节讨厌的正则\r\n\r\n*    之所以讨厌一个事物，是因为你驾驭不了它。\r\n\r\n>*\t乱七八糟的符号。\r\n>       举例：（grep  为行模式，默认以行显示）\r\n>\r\n>>  (1)\r\n>><pre><code>[root@localhost ~]# cat /etc/passwd | grep --color \"r..t\"\r\nroot:x:0:0:root:/root:/bin/bash\r\noperator:x:11:0:operator:/root:/sbin/nologin\r\nftp:x:14:50:FTP User:/var/ftp:/sbin/nologin\r\n[root@localhost ~]# \r\n</code></pre>\r\n>\r\n>><p>显示三行</p>\r\n\r\n>>  (2)\r\n>><pre><code>[root@localhost ~]# cat /etc/passwd | grep --color 'root'\r\nroot:x:0:0:root:/root:/bin/bash\r\noperator:x:11:0:operator:/root:/sbin/nologin\r\n[root@localhost ~]#\r\n</code></pre>\r\n>><p>显示两行</p>\r\n>>\t(3)\r\n>><pre><code>[root@localhost ~]# cat /etc/passwd | grep --color '^root'\r\nroot:x:0:0:root:/root:/bin/bash\r\n[root@localhost ~]#\r\n</code></pre>\r\n>><p>显示一行 </p> \r\n> \r\n>>*\t总结以上`:`什么是正则，两个单引号中间的部分就是正则。 \r\n> \r\n>\r\n>*    2.正则有什么用？</p> \r\n>\r\n>***\r\n>> <p>1.\t查找匹配</p>\r\n> \r\n>><p> 1)一个字符（如何在整篇文章中查找一个字符），正则提供了一些特殊符号，通过这\r\n些符号去替换一些东西.</p>\r\n>>\r\n><p>举例：在整篇文章中查找字母a</p> \r\n>\t\t\r\n>>使用vi编辑器打开/etc/passwd \r\n\r\n>>在末行模式下查找a \r\n>输入   ：/a/  \r\n>比如要查找abc，是一个或的关系,那么用 [ ] 。  \r\n>>输入  ：/[abc]/      \r\n>    ：/[a-c]/  \r\n>\t：/a|b|c/\r\n>\r\n>>中括号，把你想要定位的东西写入里面。\r\n> \r\n>>`.`\t任意一个字符。 \r\n> \r\n>>`[]`  选择中括号里面的任意一个。 \r\n> \r\n>>`[^]`  取非，取反 \r\n> \r\n>>`[:alnum:]`阿尔法字符加数字 \r\n> \r\n>>`[:alpha:]`任意一个字符`[[:alpha]]` \r\n> \r\n>>`[:digit:]`任意一个数字 `[[:digit:]]`（对它取反的话`[^[:digit:]]`）意为除了任意一个数字。 \r\n> \r\n>>`[:lower:]`小写。  \r\n> \r\n>>`[:upper:]`大写。\r\n>\r\n>>`[:space:]`空格。\r\n>\r\n>>`[:punct:]`标点。\r\n>\r\n>>*\t总结`：`以上是如何定位一个字符。\r\n>\r\n>><p>简单的实例</p>\r\n>><code><pre>[root@localhost ~]# cat testfile | grep --color '.'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# cat testfile | grep --color 'dog'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# cat testfile | grep --color '[d|D]og'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# cat testfile | grep --color '[^dD]og'\r\npig pig .og\r\n[root@localhost ~]# cat testfile | grep --color -E 'd|p' \r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]#\r\n</code></pre>\r\n>><p>备注  –E 代表的是一个扩展的表达方式。其中dp之间的  |  代表的是或的关系，任意取一。</p>\r\n\r\n> \r\n>>转义字符  `\\` \r\n>\r\n>><p>举例：</p>\r\n>\r\n>>当 `.`  在这不转义的时候就代表是正则中的 .  代表的是匹配任意一个字符。 \r\n> \r\n>><pre><code>[root@localhost ~]# cat testfile | grep --color -E 'd.g'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# \r\n></code></pre>\r\n>><p>当`\\.`转义之后代表着文本中存在的具体的 `.`</p> \r\n> ***\r\n>*\t2.字符的边界，查找匹配多个字符用到字符边界。\r\n>>\r\n>>`^`开头（一行开头）\t\r\n>\r\n>>`$`  结尾（一行结尾） \r\n> \r\n>>`\\<`左边界\r\n>\r\n>>`\\>`右边界     \r\n>><pre><code>[root@localhost ~]# cat -A /etc/passwd\r\nroot:x:0:0:root:/root:/bin/bash$\r\nbin:x:1:1:bin:/bin:/sbin/nologin$\r\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin$\r\nadm:x:3:4:adm:/var/adm:/sbin/nologin$\r\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin$\r\nsync:x:5:0:sync:/sbin:/bin/sync$\r\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown$\r\nhalt:x:7:0:halt:/sbin:/sbin/halt$\r\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin$\r\nuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin$\r\noperator:x:11:0:operator:/root:/sbin/nologin$\r\ngames:x:12:100:games:/usr/games:/sbin/nologin$\r\ngopher:x:13:30:gopher:/var/gopher:/sbin/nologin$\r\nftp:x:14:50:FTP User:/var/ftp:/sbin/nologin$\r\n.......\r\n</code></pre>\r\n>><p>以上结尾为`$`代表着这一行的字符边界。</p>\r\n>><p>linux与windows之间格式在linux下面的转换方法</p>\r\n>><p>命令`dos2unix` win格式转换linux </p>\r\n>><p>命令`unix2dos`  linux格式转换成win</p>\r\n>***\r\n>*\t3.重复\r\n>><p> *  重复0次或多次。注意ls *  中的 * 不是正则，是shell中的通配符。正则中的*代表前面出现了0次或者多次。  * 〉=0 </p>\r\n>><p>举例：匹配所有字符，字符每个出现次数大于等于0次 </p>\r\n>><pre><code>\r\n[root@localhost ~]# cat testfile |  grep --color '.*'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>>***\r\n>><p>a的次数大于等于0次，字符中没有a，它就相当于没有，所以匹配所有。</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color 'a*'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>>***\r\n>><p>字符中有d，第一行出现一次。第二行没有出现等于0次，那么匹配。第三行一次，第四行没\r\n有那就等于0次，那么匹配。</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color 'd*'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>>***\r\n>><p>匹配d，所有出现d的行都匹配出来。 </p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color 'd'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>***\r\n>><p>+匹配一个或者多个。+〉=1 </p> \r\n>><p>举例：匹配d，d+  表示每一行匹配d的次数大于等于1.</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E 'd+'\r\ndog pig Dog\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]#</code></pre>\r\n>***\r\n>><p>？匹配0个或者一个。〈=1 </p>\r\n>><p>举例：匹配d，  d？  表示每一行匹配d的次数小于等于一次。</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E 'd?'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog</code></pre>\r\n>***\r\n>><p>精确匹配次数。 </p>\r\n>><p>{}  中填入数字代表匹配次数。大于等于次数的行被匹配出。</p> \r\n>><p>举例：a精确匹配5次。a出现的次数大于等于5次的行被匹配。</p>\r\n>\r\n>><pre><code>[root@localhost ~]# cat testfile \r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\naa\r\naaa\r\naaaa\r\naaaaa\r\naaaaa\r\naaaaaaa\r\naaaaaaaa\r\n[root@localhost ~]# cat testfile |  grep --color 'a\\{5\\}'\r\naaaaa\r\naaaaa\r\naaaaaaa\r\naaaaaaaa\r\n[root@localhost ~]# \r\n>></code></pre>\r\n>***\r\n>><p>精确到范围。</p> \r\n>><p>{n，m} </p>  \r\n>><p>举例：匹配3至5，包括3和5.</p>\r\n>><code><pre>[root@localhost ~]# cat testfile |  grep --color 'a\\{3,5\\}'\r\naaa\r\naaaa\r\naaaaa\r\naaaaa\r\naaaaaaa\r\naaaaaaaa\r\n[root@localhost ~]# </code></pre>\r\n>***\r\n>*\t4.组 \r\n>*\t组的重复\r\n>><p>举例：pig一组，dog一组。其中的  | 有或的意思，如果有组pig或者dog，就匹配这一行。 </p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog)+'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dog dog dog\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>***\r\n>><p>pig一组，dog一组。Pig或者dog出现的次数大于等于1次，就匹配这一行。 </p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog)+'\r\ndog pig Dog\r\npig pig .og\r\ndog d.g dogdog !dog ddog!\r\npig bird dog\r\n[root@localhost ~]# </code></pre>\r\n>***\r\n>><p>Pig一组，dog一组。Pig或者dog出现满足某一行精确到出现两次就匹配。</p>\r\n>><pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog){2}'\r\ndog d.g dogdog !dog ddog!\r\n[root@localhost ~]#</code></pre>\r\n>***\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}