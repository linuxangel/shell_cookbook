<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Shell cookbook : 让你的shell 风生水起" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Shell cookbook</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/linuxangel/shell_cookbook">View on GitHub</a>

          <h1 id="project_title">Shell cookbook</h1>
          <h2 id="project_tagline">让你的shell 风生水起</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/linuxangel/shell_cookbook/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/linuxangel/shell_cookbook/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h6>第一章Shell  之讨厌的正则</h6>

<h3>linux 天使团团长：隋成龙</h3>

<h3>编辑整理：邢耀东</h3>

<ul>
<li>思想（KISS）相当重要.</li>
<li>  我们遵循KISS原则  （keep it simple，stupid） </li>
<li>  这事其实不难，只要按照以下思路进行就行了。 </li>
</ul><blockquote>
<ol>
<li> 把复杂的问题简单化，模块化 </li>
<li> 写出每一个模块的伪码。 </li>
<li> 组装你的模块 </li>
<li> 写出shell code </li>
<li>  测试（test） </li>
</ol>
</blockquote>

<h4>知道什么时候用什么实现，远比你知道怎么写code更重要。（shell不是万能的，择优取之。</h4>

<h4>shell最精华，最美的地方在于有现成的命令可以使用，不用考虑过多的底层的问题。作为上</h4>

<h4>层工作的最好的工具，所谓上层系统管理，网络管理等等。）</h4>

<h3>战略决定生死，细节决定成败</h3>

<h2>以下是我们以后将要更新的章节</h2>

<ul>
<li>  讨厌的正则</li>
<li>  可爱的变量</li>
<li>  简单明了的输入输出</li>
<li>  神奇的判断</li>
<li>  不可不会的文件操作</li>
<li>  瞬间飞升</li>
</ul><h3>第一节讨厌的正则</h3>

<ul>
<li>   之所以讨厌一个事物，是因为你驾驭不了它。</li>
</ul><blockquote>
<ul>
<li> 乱七八糟的符号。
  举例：（grep  为行模式，默认以行显示）</li>
</ul>
<blockquote>
<p>(1)</p>

<pre><code>[root@localhost ~]# cat /etc/passwd | grep --color "r..t"
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
[root@localhost ~]# 
</code></pre>

<p>显示三行</p>

<p>(2)</p>

<pre><code>[root@localhost ~]# cat /etc/passwd | grep --color 'root'
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
[root@localhost ~]#
</code></pre>

<p>显示两行</p>

<p>(3)</p>

<pre><code>[root@localhost ~]# cat /etc/passwd | grep --color '^root'
root:x:0:0:root:/root:/bin/bash
[root@localhost ~]#
</code></pre>

<p>显示一行 </p> 

<ul>
<li>总结以上<code>:</code>什么是正则，两个单引号中间的部分就是正则。 </li>
</ul>
</blockquote>

<ul>
<li>   2.正则有什么用？ </li>
</ul>
<hr>
<blockquote>
<p>1.    查找匹配</p>

<p> 1)一个字符（如何在整篇文章中查找一个字符），正则提供了一些特殊符号，通过这
些符号去替换一些东西.</p>

<p>举例：在整篇文章中查找字母a</p> 
      

<p>使用vi编辑器打开/etc/passwd </p>

<p>在末行模式下查找a 
输入   ：/a/<br>
比如要查找abc，是一个或的关系,那么用 [ ] 。<br>
输入  ：/[abc]/<br>
   ：/[a-c]/<br>
  ：/a|b|c/</p>

<p>中括号，把你想要定位的东西写入里面。</p>

<p><code>.</code>   任意一个字符。 </p>

<p><code>[]</code>  选择中括号里面的任意一个。 </p>

<p><code>[^]</code>  取非，取反 </p>

<p><code>[:alnum:]</code>阿尔法字符加数字 </p>

<p><code>[:alpha:]</code>任意一个字符<code>[[:alpha]]</code> </p>

<p><code>[:digit:]</code>任意一个数字 <code>[[:digit:]]</code>（对它取反的话<code>[^[:digit:]]</code>）意为除了任意一个数字。 </p>

<p><code>[:lower:]</code>小写。  </p>

<p><code>[:upper:]</code>大写。</p>

<p><code>[:space:]</code>空格。</p>

<p><code>[:punct:]</code>标点。</p>

<ul>
<li>总结<code>：</code>以上是如何定位一个字符。</li>
</ul>
<p>简单的实例</p>

<p><code><pre>[root@localhost ~]# cat testfile | grep --color '.'
dog pig Dog
pig pig .og
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# cat testfile | grep --color 'dog'
dog pig Dog
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# cat testfile | grep --color '[d|D]og'
dog pig Dog
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# cat testfile | grep --color '[^dD]og'
pig pig .og
[root@localhost ~]# cat testfile | grep --color -E 'd|p' 
dog pig Dog
pig pig .og
dog d.g dog dog dog
pig bird dog
[root@localhost ~]#
</pre></code></p>

<p>备注  –E 代表的是一个扩展的表达方式。其中dp之间的  |  代表的是或的关系，任意取一。</p>

<p>转义字符  <code>\</code> </p>

<p>举例：</p>

<p>当 <code>.</code>  在这不转义的时候就代表是正则中的 .  代表的是匹配任意一个字符。 </p>

<pre><code>[root@localhost ~]# cat testfile | grep --color -E 'd.g'
dog pig Dog
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# 
</code></pre>

<p>当`\.`转义之后代表着文本中存在的具体的 `.`</p> 

<hr>
<ul>
<li> 2.字符的边界，查找匹配多个字符用到字符边界。</li>
</ul>
<p><code>^</code>开头（一行开头）   </p>

<p><code>$</code>  结尾（一行结尾） </p>

<p><code>\&lt;</code>左边界</p>

<p><code>\&gt;</code>右边界     </p>

<pre><code>[root@localhost ~]# cat -A /etc/passwd
root:x:0:0:root:/root:/bin/bash$
bin:x:1:1:bin:/bin:/sbin/nologin$
daemon:x:2:2:daemon:/sbin:/sbin/nologin$
adm:x:3:4:adm:/var/adm:/sbin/nologin$
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin$
sync:x:5:0:sync:/sbin:/bin/sync$
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown$
halt:x:7:0:halt:/sbin:/sbin/halt$
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin$
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin$
operator:x:11:0:operator:/root:/sbin/nologin$
games:x:12:100:games:/usr/games:/sbin/nologin$
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin$
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin$
.......
</code></pre>

<p>以上结尾为`$`代表着这一行的字符边界。</p>

<p>linux与windows之间格式在linux下面的转换方法</p>

<p>命令`dos2unix` win格式转换linux </p>

<p>命令`unix2dos`  linux格式转换成win</p>

<hr>
<ul>
<li> 3.重复
<p> *  重复0次或多次。注意ls *  中的 * 不是正则，是shell中的通配符。正则中的*代表前面出现了0次或者多次。  * 〉=0 </p>
<p>举例：匹配所有字符，字符每个出现次数大于等于0次 </p>
<pre><code>
[root@localhost ~]# cat testfile |  grep --color '.*'
dog pig Dog
pig pig .og
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# </code></pre>
***
<p>a的次数大于等于0次，字符中没有a，它就相当于没有，所以匹配所有。</p>
<pre><code>[root@localhost ~]# cat testfile |  grep --color 'a*'
dog pig Dog
pig pig .og
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# </code></pre>
***
<p>字符中有d，第一行出现一次。第二行没有出现等于0次，那么匹配。第三行一次，第四行没
有那就等于0次，那么匹配。</p>
<pre><code>[root@localhost ~]# cat testfile |  grep --color 'd*'
dog pig Dog
pig pig .og
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# </code></pre>
***
<p>匹配d，所有出现d的行都匹配出来。 </p>
<pre><code>[root@localhost ~]# cat testfile |  grep --color 'd'
dog pig Dog
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# </code></pre>
***
<p>+匹配一个或者多个。+〉=1 </p> 
<p>举例：匹配d，d+  表示每一行匹配d的次数大于等于1.</p>
<pre><code>[root@localhost ~]# cat testfile |  grep --color -E 'd+'
dog pig Dog
dog d.g dog dog dog
pig bird dog
[root@localhost ~]#</code></pre>
***
<p>？匹配0个或者一个。〈=1 </p>
<p>举例：匹配d，  d？  表示每一行匹配d的次数小于等于一次。</p>
<pre><code>[root@localhost ~]# cat testfile |  grep --color -E 'd?'
dog pig Dog
pig pig .og
dog d.g dog dog dog
pig bird dog</code></pre>
***
<p>精确匹配次数。 </p>
<p>{}  中填入数字代表匹配次数。大于等于次数的行被匹配出。</p> 
<p>举例：a精确匹配5次。a出现的次数大于等于5次的行被匹配。</p>
</li>
</ul>
<pre><code>[root@localhost ~]# cat testfile 
dog pig Dog
pig pig .og
dog d.g dog dog dog
pig bird dog
aa
aaa
aaaa
aaaaa
aaaaa
aaaaaaa
aaaaaaaa
[root@localhost ~]# cat testfile |  grep --color 'a\{5\}'
aaaaa
aaaaa
aaaaaaa
aaaaaaaa
[root@localhost ~]# 
</code></pre>

<hr>
<p>精确到范围。</p> 

<p>{n，m} </p>  

<p>举例：匹配3至5，包括3和5.</p>

<p><code><pre>[root@localhost ~]# cat testfile |  grep --color 'a{3,5}'
aaa
aaaa
aaaaa
aaaaa
aaaaaaa
aaaaaaaa
[root@localhost ~]# </pre></code></p>

<hr>
<ul>
<li> 4.组 </li>
<li> 组的重复
<p>举例：pig一组，dog一组。其中的  | 有或的意思，如果有组pig或者dog，就匹配这一行。 </p>
<pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog)+'
dog pig Dog
pig pig .og
dog d.g dog dog dog
pig bird dog
[root@localhost ~]# </code></pre>
***
<p>pig一组，dog一组。Pig或者dog出现的次数大于等于1次，就匹配这一行。 </p>
<pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog)+'
dog pig Dog
pig pig .og
dog d.g dogdog !dog ddog!
pig bird dog
[root@localhost ~]# </code></pre>
***
<p>Pig一组，dog一组。Pig或者dog出现满足某一行精确到出现两次就匹配。</p>
<pre><code>[root@localhost ~]# cat testfile |  grep --color -E '(pig|dog){2}'
dog d.g dogdog !dog ddog!
[root@localhost ~]#</code></pre>
***</li>
</ul>
</blockquote>
</blockquote>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Shell cookbook maintained by <a href="https://github.com/linuxangel">linuxangel</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
